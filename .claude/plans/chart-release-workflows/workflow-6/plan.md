# Workflow 6: Atomic Chart Tagging - Phase Plan

## Overview
**Trigger**: `push` → `main` branch (with changes to `charts/**`)
**Purpose**: Create immutable annotated tags and open PR to release branch

---

## Relevant Skills

Load these skills before planning, research, or implementation:

| Skill | Path | Relevance |
|-------|------|-----------|
| **CI/CD GitHub Actions** | `~/.claude/skills/cicd-github-actions-dev/SKILL.md` | Tag creation, gh CLI patterns, PR creation |
| **Helm Chart Development** | `~/.claude/skills/k8s-helm-charts-dev/SKILL.md` | Chart versioning, semantic version extraction |
| **GitHub App Development** | `~/.claude/skills/github-app-dev/SKILL.md` | If elevated permissions needed for tag creation |

**How to load**: Read the SKILL.md files at the start of implementation to access patterns and best practices.

---

## Prerequisites

### Shared Components Required (Build First)
- [x] `detect_changed_charts` shell function (implemented in attestation-lib.sh)
- [x] `extract_attestation_map` shell function (implemented in attestation-lib.sh)

### Infrastructure Required
- [x] `release-tag-protection` ruleset configured (blocks manual tag creation)
- [x] GitHub App token with tag creation permissions (via 1Password: `op://gh-shared/xauth/app/*`)
- [x] `release` branch created

### Upstream Dependencies
- [x] Workflow 5 must have merged the PR (triggers this workflow)

---

## Implementation Phases

### Phase 6.1: Base Workflow Structure
**Effort**: Low
**Dependencies**: None

**Tasks**:
1. Create `.github/workflows/atomic-chart-tagging.yaml`
2. Configure trigger for `push` → `main` with path filter `charts/**`
3. Set up permissions (contents: write, pull-requests: write)
4. Use GitHub App token for tag creation (to bypass tag protection)

**Code**:
```yaml
name: W6 - Atomic Chart Tagging

on:
  push:
    branches:
      - main
    paths:
      - 'charts/**'

permissions:
  contents: write
  pull-requests: write

jobs:
  tag-and-release-pr:
    runs-on: ubuntu-latest
    steps:
      - name: Load secrets from 1Password
        id: op-secrets
        uses: 1password/load-secrets-action@v2
        with:
          export-env: false
        env:
          OP_SERVICE_ACCOUNT_TOKEN: ${{ secrets.OP_SERVICE_ACCOUNT_TOKEN }}
          X_REPO_AUTH_APP_ID: op://gh-shared/xauth/app/id
          X_REPO_AUTH_PRIVATE_KEY: op://gh-shared/xauth/app/private-key.pem

      - name: Generate GitHub App Token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ steps.op-secrets.outputs.X_REPO_AUTH_APP_ID }}
          private-key: ${{ steps.op-secrets.outputs.X_REPO_AUTH_PRIVATE_KEY }}
```

**Deliverable**: Workflow triggers on merge to main with chart changes

---

### Phase 6.2: Chart Detection
**Effort**: Low
**Dependencies**: Phase 6.1, `detect_changed_charts`

**Tasks**:
1. Detect which charts changed in this merge
2. For each chart, get current version from Chart.yaml
3. Store list for iteration

**Code**:
```bash
source .github/scripts/attestation-lib.sh

# Detect charts changed in this push
CHARTS=$(detect_changed_charts "HEAD~1..HEAD")

for chart in $CHARTS; do
  VERSION=$(grep '^version:' "charts/$chart/Chart.yaml" | awk '{print $2}')
  echo "Chart: $chart, Version: $VERSION"
done
```

---

### Phase 6.3: Source PR Discovery
**Effort**: Medium
**Dependencies**: Phase 6.1, `extract_attestation_map`

**Tasks**:
1. Find the PR that was merged (created this push)
2. Extract attestation map from PR body
3. Store for tag annotation

**Code**:
```bash
source .github/scripts/attestation-lib.sh

# Find merged PR for this commit
PR_NUMBER=$(gh pr list \
  --state merged \
  --search "${{ github.sha }}" \
  --json number \
  --limit 1 \
  -q '.[0].number')

if [[ -z "$PR_NUMBER" ]]; then
  echo "::warning::Could not find merged PR for commit ${{ github.sha }}"
  PR_NUMBER="unknown"
  ATTESTATION_MAP="{}"
else
  ATTESTATION_MAP=$(extract_attestation_map "$PR_NUMBER")
fi
```

---

### Phase 6.4: Changelog Extraction
**Effort**: Medium
**Dependencies**: Phase 6.2

**Tasks**:
1. For each chart, read `charts/<chart>/CHANGELOG.md`
2. Extract entries for the current version using Keep-a-Changelog format
3. Format for tag annotation

**Changelog Format** (generated by release-please):
```markdown
# Changelog

## [0.4.0](https://github.com/.../compare/chart-v0.3.0...chart-v0.4.0) (2024-01-15)

### Features

* **chart:** add new feature ([#42](https://github.com/...))

### Bug Fixes

* fix something ([#41](https://github.com/...))

## [0.3.0](https://github.com/...) (2024-01-10)
...
```

**Extraction Code**:
```bash
extract_changelog_for_version() {
  local chart="$1"
  local version="$2"
  local changelog_file="charts/$chart/CHANGELOG.md"

  if [[ ! -f "$changelog_file" ]]; then
    echo "No changelog available"
    return 0
  fi

  # Extract section from ## [VERSION] until next ## [ or end of file
  # Using awk to handle the Keep-a-Changelog format
  awk -v ver="$version" '
    /^## \[/ {
      if (found) exit
      if ($0 ~ "\\[" ver "\\]") found=1
    }
    found { print }
  ' "$changelog_file"
}

CHANGELOG=$(extract_changelog_for_version "$CHART" "$VERSION")
```

**Fallback**: If CHANGELOG.md is missing or empty, use:
```
No changelog entries for this version.
See commit history for changes.
```

---

### Phase 6.5: Tag Creation
**Effort**: High
**Dependencies**: Phase 6.3, Phase 6.4, GitHub App token

**Tasks**:
1. For each chart:
   - Construct tag name: `<chart>-v<version>`
   - Check if tag already exists (see Existing Tag Handling below)
   - Create annotated tag with full metadata
   - Push tag using App token

**Tag Annotation Format**:
```
Release: <chart> v<version>

Attestation Lineage:
- w1-lint: <attestation-id>
- w1-artifacthub-lint: <attestation-id>
- w5-verification: <attestation-id>
- w5-semver: <attestation-id>
- k8s-install-v1.32.11: <attestation-id>
- k8s-install-v1.33.7: <attestation-id>
- k8s-install-v1.34.3: <attestation-id>

Changelog:
<changelog content>

Source PR: #<number>
Commit: <sha>
```

**Code**:
```bash
TAG_NAME="${CHART}-v${VERSION}"

# Check existing tag (see detailed handling below)
if git rev-parse "$TAG_NAME" >/dev/null 2>&1; then
  EXISTING_TAG_COMMIT=$(git rev-list -n 1 "$TAG_NAME")
  if [[ "$EXISTING_TAG_COMMIT" == "${{ github.sha }}" ]]; then
    echo "::notice::Tag $TAG_NAME already exists and points to this commit. Skipping."
    continue
  else
    echo "::error::Tag $TAG_NAME already exists but points to different commit!"
    echo "::error::Existing: $EXISTING_TAG_COMMIT, Current: ${{ github.sha }}"
    echo "::error::This indicates either:"
    echo "::error::  1. Version was not bumped by W5"
    echo "::error::  2. Tag was created manually (policy violation)"
    echo "::error::Resolution: Investigate and ensure version is incremented."
    exit 1
  fi
fi

# Create annotated tag
git tag -a "$TAG_NAME" -m "$(cat <<EOF
Release: $CHART v$VERSION

Attestation Lineage:
$(echo "$ATTESTATION_MAP" | jq -r 'to_entries | .[] | "- \(.key): \(.value)"')

Changelog:
$CHANGELOG

Source PR: #$PR_NUMBER
Commit: ${{ github.sha }}
EOF
)"

# Push tag using App token
git push origin "$TAG_NAME"
```

---

### Phase 6.5a: Existing Tag Handling (Critical)
**Effort**: Low
**Dependencies**: Phase 6.5

Tags in this repository are **immutable** - once created, they should never be modified or recreated.

**Scenarios and Resolutions**:

| Scenario | Detection | Action |
|----------|-----------|--------|
| W6 re-run after success | Tag exists, points to HEAD | **Skip** with notice (idempotent) |
| W6 re-run after failure | Tag exists, points to HEAD | **Skip** with notice (idempotent) |
| Manual tag creation | Tag exists, points to different commit | **Fail** with error |
| Version not bumped (W5 bug) | Tag exists, points to different commit | **Fail** with error |
| Race condition | Tag exists, points to different commit | **Fail** with error |

**Decision Tree**:
```
IF tag exists:
  IF tag points to current commit (HEAD):
    → SKIP with notice "Tag already exists and points to this commit"
  ELSE:
    → FAIL with error:
      "Tag exists but points to different commit.
       Existing: <commit>, Current: <commit>
       This indicates either:
       1. Version was not bumped by W5
       2. Tag was created manually (policy violation)
       3. Unexpected race condition
       Resolution: Investigate and ensure version is incremented."
ELSE:
  → CREATE tag
```

**Why not "skip with warning" for all cases?**
If a tag exists pointing to a different commit, silently skipping would:
- Allow untagged releases to slip through
- Mask W5 bugs where version wasn't bumped
- Hide policy violations (manual tagging)

---

### Phase 6.6: PR to Release Branch
**Effort**: Medium
**Dependencies**: Phase 6.5

**Approach**: One PR per chart release.

**Why one PR per chart?**
- Each release contains only one chart at a specific version
- Clear audit trail per chart
- Related assets (changelog, attestations, README) are chart-specific
- Enables independent release timing for different charts
- Simplifies W7/W8 processing

**How it works**:
1. Chart A merges to main → W6 creates tag → W6 creates PR "release: chartA-v1.0.0"
2. Chart B merges to main → W6 creates tag → W6 creates PR "release: chartB-v2.0.0"
3. Reviewer merges each PR independently → Each triggers W7/W8 for that chart

**Code**:
```bash
# Create one PR per chart
for chart in $TAGGED_CHARTS; do
  VERSION=$(grep '^version:' "charts/$chart/Chart.yaml" | awk '{print $2}')
  TAG_NAME="${chart}-v${VERSION}"

  # Check if PR already exists for this chart release
  EXISTING_PR=$(gh pr list \
    --head main \
    --base release \
    --state open \
    --search "release: ${TAG_NAME}" \
    --json number \
    --limit 1 \
    -q '.[0].number')

  if [[ -n "$EXISTING_PR" ]]; then
    echo "::notice::Release PR for $TAG_NAME already exists: #$EXISTING_PR"
    continue
  fi

  # Create PR for this chart
  gh pr create \
    --head main \
    --base release \
    --title "release: ${TAG_NAME}" \
    --body "$(generate_pr_body "$chart" "$VERSION" "$TAG_NAME")"

  echo "::notice::Created release PR for $TAG_NAME"
done
```

**PR Body Template** (one PR per chart):
```markdown
## Release: <chart> v<version>

This PR releases **<chart>** at version **<version>**.

### Tag
- **Tag**: `<chart>-v<version>`
- **Source PR**: #<pr-number>
- **Commit**: <sha>

### Changelog

<changelog content extracted from charts/<chart>/CHANGELOG.md>

### Attestation Lineage

| Check | Attestation ID |
|-------|----------------|
| w1-lint | <id> |
| w5-verification | <id> |
| ... | ... |

### Merge Instructions

When this PR is merged to `release`:
1. W7 will verify tag attestations and build chart package
2. W8 will publish to GHCR and create GitHub Release

---
*Auto-generated by W6: Atomic Chart Tagging*
```

---

### Phase 6.7: Branch Cleanup
**Effort**: Low
**Dependencies**: Phase 6.5

**Tasks**:
1. Delete `integration/<chart>` branches after successful tagging
2. Only delete branches for charts that were successfully tagged

**Code**:
```bash
for chart in $TAGGED_CHARTS; do
  BRANCH="integration/$chart"
  if git ls-remote --heads origin "$BRANCH" | grep -q "$BRANCH"; then
    git push origin --delete "$BRANCH"
    echo "::notice::Deleted branch: $BRANCH"
  fi
done
```

**Safety**: Only delete after tag is confirmed pushed.

---

## File Structure

```
.github/
├── workflows/
│   └── atomic-chart-tagging.yaml    # Main workflow
└── scripts/
    └── attestation-lib.sh           # Shared functions
```

---

## Dependencies Graph

```
┌──────────────────────┐
│ Workflow 5 merges    │
│ PR to main           │
└──────────┬───────────┘
           │
           ▼
┌──────────────────────┐
│ Phase 6.1: Base      │
│ Workflow + App Token │
└──────────┬───────────┘
           │
     ┌─────┼─────┐
     ▼     ▼     ▼
┌──────┐ ┌──────┐ ┌──────────┐
│6.2   │ │6.3   │ │6.4       │
│Chart │ │Source│ │Changelog │
│Detect│ │PR    │ │Extract   │
└──┬───┘ └──┬───┘ └────┬─────┘
   │        │          │
   └────────┼──────────┘
            ▼
┌──────────────────────┐
│ Phase 6.5: Tag       │
│ Creation             │
├──────────────────────┤
│ Phase 6.5a: Existing │
│ Tag Handling         │
└──────────┬───────────┘
           │
           ▼
┌──────────────────────┐
│ Phase 6.6: PR to     │
│ Release (rolling)    │
└──────────┬───────────┘
           │
           ▼
┌──────────────────────┐
│ Phase 6.7: Branch    │
│ Cleanup              │
└──────────────────────┘
```

---

## Tag Format Enforcement

The tag format `<chart>-v<major>.<minor>.<patch>` is enforced through multiple controls:

### Documentation
- **ADR-006**: [Immutable Release Tags](../adr/ADR-006-immutable-release-tags.md) documents the format and rationale

### Code Convention
- **release-please.yaml** (line 88): Constructs tags as `${chart_name}-v${version}`
- **W6 workflow**: Will construct tags using the same pattern
- **attestation-lib.sh**: Version extraction functions return semver format

### Changelog Tooling
- **cliff.toml**: `tag_pattern = ".*-v[0-9]+\\.[0-9]+\\.[0-9]+"` expects this pattern for changelog generation

### Immutability Protection
- **Ruleset**: "tags: immutable release tags" (ID: 11880166)
  - Target: All tags (`~ALL`)
  - Rules: Prevent deletion, prevent updates
  - Result: Once created, tags cannot be modified or removed

### What's NOT Enforced
- **Creation pattern**: No ruleset prevents creating tags with different patterns (e.g., `v1.0.0` without chart prefix)
- **Reason**: GitHub tag rulesets can restrict who creates, but not the format
- **Mitigation**: Only workflows create tags; workflows enforce the format in code

---

## Open Questions - Answered

### 1. Tag Push Permissions
**Q**: How to push tags with tag protection enabled?
**A**: Use the existing GitHub App token (same as release-please). The App is configured with `contents: write` permission. The tag protection ruleset is configured to allow the GitHub App to bypass.

### 2. Changelog Format
**Q**: Where does changelog content come from?
**A**: From `charts/<chart>/CHANGELOG.md`, generated by release-please in Keep-a-Changelog format. W6 extracts the section for the current version using awk pattern matching:
- Start at `## [VERSION]` header
- End at next `## [` header or EOF
- Include all content between (features, fixes, etc.)

Example extraction from real changelog:
```markdown
## [0.4.0](https://github.com/aRustyDev/helm-charts/compare/cloudflared-v0.3.0...cloudflared-v0.4.0) (2026-01-14)

### Features

* **cloudflared:** add base cloudflared helm chart (MVP) ([#35](https://github.com/...))
* **cloudflared:** add External Secrets Operator integration ([#37](https://github.com/...))
```

### 3. Multiple Charts
**Q**: How to handle multiple charts in one merge?
**A**: Process each chart independently in a loop. Each gets its own tag. All tags are collected and included in a single release PR.

### 4. Existing Tags
**Q**: Skip or fail if tag exists?
**A**: **Conditional** - See Phase 6.5a for detailed handling:
- If tag exists AND points to current commit → **Skip** (idempotent, re-run safe)
- If tag exists AND points to different commit → **Fail** (indicates bug or policy violation)

This distinction is critical because silently skipping a mismatched tag would mask:
- W5 bugs where version wasn't bumped
- Policy violations (manual tagging)
- Unexpected race conditions

### 5. PR Batching
**Q**: One release PR per tag or batch?
**A**: **One PR per chart release**. Each chart gets its own release PR:
1. Chart A merges to main → W6 creates tag → W6 creates PR "release: chartA-v1.0.0"
2. Chart B merges to main → W6 creates tag → W6 creates PR "release: chartB-v2.0.0"
3. Reviewer merges each PR independently → Each triggers W7/W8

Benefits:
- Each release contains exactly one chart at one version
- Clear audit trail per chart
- Related assets (changelog, attestations) are chart-specific
- Independent release timing for different charts
- Simplifies W7/W8 processing

### 6. Branch Cleanup
**Q**: When and how to delete integration branches?
**A**: W6 deletes `integration/<chart>` branches immediately after successful tag creation for that chart. Cleanup is per-chart (not batched) to ensure only successfully tagged charts have branches removed.

---

## Risks

| Risk | Impact | Mitigation |
|------|--------|------------|
| Can't push tags due to protection | High | Configure ruleset bypass for GitHub App |
| Tag already exists (different commit) | High | Fail with clear error, require investigation |
| Tag already exists (same commit) | Low | Skip gracefully (idempotent) |
| Source PR not found | Medium | Fallback to commit info, log warning |
| Changelog missing | Low | Use fallback message, proceed anyway |
| Multiple workflow runs | Low | Existing tag check handles idempotency |
| GitHub App token issues | High | Same token pattern as release-please (proven) |

---

## Success Criteria

- [ ] Workflow triggers on merge to main with chart changes
- [ ] Creates annotated tag per chart: `<chart>-v<version>`
- [ ] Tag annotation contains attestation lineage
- [ ] Tag annotation contains changelog excerpt
- [ ] Handles existing tags correctly (skip same commit, fail different)
- [ ] Pushes tags successfully using GitHub App token
- [ ] Creates/updates single rolling PR to release branch
- [ ] Deletes integration branches after tagging
- [ ] Workflow completes in < 5 minutes
