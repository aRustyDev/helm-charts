name: Release Please

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      force_release:
        description: 'Force run release-charts job (bypass release-please check)'
        required: false
        type: boolean
        default: false

permissions:
  contents: write
  pull-requests: write
  packages: write
  id-token: write
  attestations: write

jobs:
  # Release-please creates PRs and tracks releases, but we create GitHub releases manually
  # due to persistent "Resource not accessible by integration" errors with both GITHUB_TOKEN
  # and GitHub App tokens. See: https://github.com/aRustyDev/helm-charts/issues/42
  release-please:
    runs-on: ubuntu-latest
    outputs:
      releases_created: ${{ steps.release.outputs.releases_created }}
      paths_released: ${{ steps.release.outputs.paths_released }}
      pending_releases_created: ${{ steps.pending-releases.outputs.releases_created }}
      # Cloudflared outputs
      cloudflared--release_created: ${{ steps.release.outputs['charts/cloudflared--release_created'] }}
      cloudflared--tag_name: ${{ steps.release.outputs['charts/cloudflared--tag_name'] }}
      cloudflared--version: ${{ steps.release.outputs['charts/cloudflared--version'] }}
      cloudflared--sha: ${{ steps.release.outputs['charts/cloudflared--sha'] }}
      # mdbook-htmx outputs
      mdbook-htmx--release_created: ${{ steps.release.outputs['charts/mdbook-htmx--release_created'] }}
      mdbook-htmx--tag_name: ${{ steps.release.outputs['charts/mdbook-htmx--tag_name'] }}
      mdbook-htmx--version: ${{ steps.release.outputs['charts/mdbook-htmx--version'] }}
      mdbook-htmx--sha: ${{ steps.release.outputs['charts/mdbook-htmx--sha'] }}
      # OLM outputs
      olm--release_created: ${{ steps.release.outputs['charts/olm--release_created'] }}
      olm--tag_name: ${{ steps.release.outputs['charts/olm--tag_name'] }}
      olm--version: ${{ steps.release.outputs['charts/olm--version'] }}
      olm--sha: ${{ steps.release.outputs['charts/olm--sha'] }}
    steps:
      # ============================================================
      # Step 1: Process any pending releases BEFORE release-please runs
      # This prevents release-please from aborting due to "untagged, merged PRs"
      # ============================================================
      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Process pending releases
        id: pending-releases
        run: |
          echo "Checking for merged release PRs with 'autorelease: pending' label..."
          releases_created="false"

          # Find all merged PRs with autorelease: pending label
          pending_prs=$(gh pr list --state merged --label "autorelease: pending" --json number,title,mergeCommit --jq '.[]')

          if [ -z "$pending_prs" ]; then
            echo "No pending releases found"
            echo "releases_created=false" >> $GITHUB_OUTPUT
            exit 0
          fi

          echo "Found pending release PRs:"
          echo "$pending_prs" | jq -r '.title'

          # Process each pending PR
          echo "$pending_prs" | jq -c '.' | while read -r pr; do
            pr_number=$(echo "$pr" | jq -r '.number')
            pr_title=$(echo "$pr" | jq -r '.title')
            merge_sha=$(echo "$pr" | jq -r '.mergeCommit.oid')

            echo "Processing PR #$pr_number: $pr_title"

            # Extract chart name and version from PR title
            # Expected format: "chore(main): release <chart> <version>"
            if [[ "$pr_title" =~ release[[:space:]]+([a-zA-Z0-9_-]+)[[:space:]]+([0-9]+\.[0-9]+\.[0-9]+) ]]; then
              chart_name="${BASH_REMATCH[1]}"
              version="${BASH_REMATCH[2]}"
              tag_name="${chart_name}-v${version}"

              echo "ðŸ“¦ Creating release for $chart_name v$version (tag: $tag_name)"

              # Check if release already exists
              if gh release view "$tag_name" &>/dev/null; then
                echo "âš ï¸ Release $tag_name already exists, updating label only"
              else
                # Get changelog content
                changelog_file="charts/${chart_name}/CHANGELOG.md"
                if [ -f "$changelog_file" ]; then
                  release_notes=$(awk "/^## \[$version\]/{flag=1; next} /^## \[/{flag=0} flag" "$changelog_file")
                  if [ -z "$release_notes" ]; then
                    release_notes="Release $chart_name v$version"
                  fi
                else
                  release_notes="Release $chart_name v$version"
                fi

                # Create the release
                gh release create "$tag_name" \
                  --target "$merge_sha" \
                  --title "$chart_name: v$version" \
                  --notes "$release_notes"

                echo "âœ… Created release $tag_name"
                releases_created="true"
              fi

              # Update PR label
              gh pr edit "$pr_number" --remove-label "autorelease: pending" --add-label "autorelease: tagged"
              echo "âœ… Updated PR #$pr_number label to 'autorelease: tagged'"
            else
              echo "âš ï¸ Could not parse chart name and version from PR title: $pr_title"
            fi
          done

          echo "releases_created=$releases_created" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # ============================================================
      # Step 2: Run release-please to create new PRs
      # ============================================================
      # Load GitHub App credentials from 1Password for PR creation
      # PRs created with App token trigger CI workflows (unlike GITHUB_TOKEN)
      # See: https://github.com/aRustyDev/helm-charts/issues/39
      - name: Load secrets from 1Password
        id: op-secrets
        uses: 1password/load-secrets-action@v2
        with:
          export-env: false
        env:
          OP_SERVICE_ACCOUNT_TOKEN: ${{ secrets.OP_SERVICE_ACCOUNT_TOKEN }}
          X_REPO_AUTH_APP_ID: op://gh-shared/xauth/app/id
          X_REPO_AUTH_PRIVATE_KEY: op://gh-shared/xauth/app/private-key.pem

      - name: Generate GitHub App Token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ steps.op-secrets.outputs.X_REPO_AUTH_APP_ID }}
          private-key: ${{ steps.op-secrets.outputs.X_REPO_AUTH_PRIVATE_KEY }}

      # Release-please: Creates PRs with App token, skips GitHub release creation
      # We process releases in the step above to avoid permission issues
      - uses: googleapis/release-please-action@v4
        id: release
        with:
          token: ${{ steps.app-token.outputs.token }}
          config-file: release-please-config.json
          manifest-file: .release-please-manifest.json
          skip-github-release: true

  release-charts:
    needs: release-please
    # Run if:
    # 1. release-please created releases (releases_created == 'true')
    # 2. Pending releases were processed (pending_releases_created == 'true')
    # 3. Manually triggered with force_release
    if: >
      always() && (
        needs.release-please.outputs.releases_created == 'true' ||
        needs.release-please.outputs.pending_releases_created == 'true' ||
        inputs.force_release == true
      )
    runs-on: ubuntu-latest
    permissions:
      contents: write
      packages: write
      id-token: write
      attestations: write
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Configure Git
        run: |
          git config user.name "$GITHUB_ACTOR"
          git config user.email "$GITHUB_ACTOR@users.noreply.github.com"

      - name: Set up Helm
        uses: azure/setup-helm@v4
        with:
          version: v3.14.0

      - name: Install Cosign
        uses: sigstore/cosign-installer@v3

      - name: Set registry (lowercase for OCI)
        run: |
          echo "REGISTRY=ghcr.io/${GITHUB_REPOSITORY_OWNER,,}/charts" >> $GITHUB_ENV

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # ============================================================
      # 1. GitHub Releases + Charts Branch (via chart-releaser)
      # ============================================================
      - name: Run chart-releaser
        uses: helm/chart-releaser-action@v1.7.0
        with:
          charts_dir: charts
          pages_branch: charts
          skip_existing: true
        env:
          CR_TOKEN: "${{ secrets.GITHUB_TOKEN }}"

      # ============================================================
      # 2. Sign GitHub Release assets (.tgz files)
      # ============================================================
      - name: Sign GitHub Release assets
        run: |
          for chart in charts/*/; do
            if [ -f "$chart/Chart.yaml" ]; then
              chart_name=$(grep '^name:' "$chart/Chart.yaml" | awk '{print $2}')
              version=$(grep '^version:' "$chart/Chart.yaml" | awk '{print $2}')
              tgz_file=".cr-release-packages/${chart_name}-${version}.tgz"

              if [ -f "$tgz_file" ]; then
                echo "ðŸ” Signing GitHub Release asset: $tgz_file"
                cosign sign-blob --yes --output-signature "${tgz_file}.sig" "$tgz_file"

                # Upload signature to GitHub Release
                gh release upload "${chart_name}-${version}" "${tgz_file}.sig" --clobber || true
                echo "âœ… Uploaded signature to release ${chart_name}-${version}"
              fi
            fi
          done
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # ============================================================
      # 3. GHCR / GitHub Packages (OCI Registry) + Sign by Digest
      # ============================================================
      - name: Push and sign charts to GHCR
        run: |
          for chart in charts/*/; do
            if [ -f "$chart/Chart.yaml" ]; then
              chart_name=$(grep '^name:' "$chart/Chart.yaml" | awk '{print $2}')
              version=$(grep '^version:' "$chart/Chart.yaml" | awk '{print $2}')
              tgz_file=".cr-release-packages/${chart_name}-${version}.tgz"

              # Package if needed
              if [ ! -f "$tgz_file" ]; then
                echo "ðŸ“¦ Packaging $chart_name:$version..."
                helm package "$chart" -d .cr-release-packages/
              fi

              # Push and capture digest
              echo "ðŸš€ Pushing $chart_name:$version to GHCR..."
              push_output=$(helm push "$tgz_file" oci://$REGISTRY 2>&1)
              echo "$push_output"

              # Extract digest from helm push output (format: "Digest: sha256:...")
              digest=$(echo "$push_output" | grep -oP 'Digest: \Ksha256:[a-f0-9]+')
              echo "âœ… Published $chart_name:$version (digest: $digest)"

              # Sign by digest (not tag) for security
              if [ -n "$digest" ]; then
                echo "ðŸ” Signing $REGISTRY/${chart_name}@${digest}..."
                cosign sign --yes "$REGISTRY/${chart_name}@${digest}"
                echo "âœ… Signed $chart_name:$version on GHCR"
              else
                echo "âš ï¸ Could not extract digest, skipping signing for $chart_name:$version"
              fi
            fi
          done

      # ============================================================
      # 4. Generate build attestations
      # ============================================================
      - name: Generate attestations for chart packages
        uses: actions/attest-build-provenance@v3
        with:
          subject-path: '.cr-release-packages/*.tgz'

      # ============================================================
      # Summary
      # ============================================================
      - name: Generate release summary
        run: |
          echo "## ðŸš€ Charts Released" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Chart | Version | GitHub Release | GHCR | Signed |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|---------|----------------|------|--------|" >> $GITHUB_STEP_SUMMARY

          for chart in charts/*/; do
            if [ -f "$chart/Chart.yaml" ]; then
              chart_name=$(grep '^name:' "$chart/Chart.yaml" | awk '{print $2}')
              version=$(grep '^version:' "$chart/Chart.yaml" | awk '{print $2}')
              gh_release="[${chart_name}-${version}](https://github.com/${{ github.repository }}/releases/tag/${chart_name}-${version})"
              ghcr_link="[\`$REGISTRY/${chart_name}:${version}\`](https://github.com/${{ github.repository_owner }}/packages/container/charts%2F${chart_name})"
              echo "| $chart_name | $version | $gh_release | $ghcr_link | âœ… |" >> $GITHUB_STEP_SUMMARY
            fi
          done

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Verification" >> $GITHUB_STEP_SUMMARY
          echo '```bash' >> $GITHUB_STEP_SUMMARY
          echo "# Verify GHCR signature" >> $GITHUB_STEP_SUMMARY
          echo "cosign verify $REGISTRY/<chart>:<version>" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "# Verify GitHub Release signature" >> $GITHUB_STEP_SUMMARY
          echo "cosign verify-blob --signature <chart>-<version>.tgz.sig <chart>-<version>.tgz" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
