name: Release Please

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      force_release:
        description: 'Force run release-charts job (bypass release-please check)'
        required: false
        type: boolean
        default: false

permissions:
  contents: write
  pull-requests: write
  packages: write
  id-token: write
  attestations: write

jobs:
  # Release-please creates PRs and tracks releases, but we create GitHub releases manually
  # due to persistent "Resource not accessible by integration" errors with both GITHUB_TOKEN
  # and GitHub App tokens. See: https://github.com/aRustyDev/helm-charts/issues/42
  release-please:
    runs-on: ubuntu-latest
    outputs:
      releases_created: ${{ steps.release.outputs.releases_created }}
      paths_released: ${{ steps.release.outputs.paths_released }}
      # Cloudflared outputs
      cloudflared--release_created: ${{ steps.release.outputs['charts/cloudflared--release_created'] }}
      cloudflared--tag_name: ${{ steps.release.outputs['charts/cloudflared--tag_name'] }}
      cloudflared--version: ${{ steps.release.outputs['charts/cloudflared--version'] }}
      cloudflared--sha: ${{ steps.release.outputs['charts/cloudflared--sha'] }}
      # mdbook-htmx outputs
      mdbook-htmx--release_created: ${{ steps.release.outputs['charts/mdbook-htmx--release_created'] }}
      mdbook-htmx--tag_name: ${{ steps.release.outputs['charts/mdbook-htmx--tag_name'] }}
      mdbook-htmx--version: ${{ steps.release.outputs['charts/mdbook-htmx--version'] }}
      mdbook-htmx--sha: ${{ steps.release.outputs['charts/mdbook-htmx--sha'] }}
      # OLM outputs
      olm--release_created: ${{ steps.release.outputs['charts/olm--release_created'] }}
      olm--tag_name: ${{ steps.release.outputs['charts/olm--tag_name'] }}
      olm--version: ${{ steps.release.outputs['charts/olm--version'] }}
      olm--sha: ${{ steps.release.outputs['charts/olm--sha'] }}
    steps:
      # Load GitHub App credentials from 1Password for PR creation
      # PRs created with App token trigger CI workflows (unlike GITHUB_TOKEN)
      # See: https://github.com/aRustyDev/helm-charts/issues/39
      - name: Load secrets from 1Password
        id: op-secrets
        uses: 1password/load-secrets-action@v2
        with:
          export-env: false
        env:
          OP_SERVICE_ACCOUNT_TOKEN: ${{ secrets.OP_SERVICE_ACCOUNT_TOKEN }}
          X_REPO_AUTH_APP_ID: op://gh-shared/xauth/app/id
          X_REPO_AUTH_PRIVATE_KEY: op://gh-shared/xauth/app/private-key.pem

      - name: Generate GitHub App Token
        id: app-token
        uses: actions/create-github-app-token@v1
        with:
          app-id: ${{ steps.op-secrets.outputs.X_REPO_AUTH_APP_ID }}
          private-key: ${{ steps.op-secrets.outputs.X_REPO_AUTH_PRIVATE_KEY }}

      # Release-please: Creates PRs with App token, skips GitHub release creation
      # We create releases manually in release-charts job to avoid permission issues
      - uses: googleapis/release-please-action@v4
        id: release
        with:
          token: ${{ steps.app-token.outputs.token }}
          config-file: release-please-config.json
          manifest-file: .release-please-manifest.json
          skip-github-release: true

      # Create GitHub releases manually using GITHUB_TOKEN
      # This works because we're using gh CLI, not the release-please internal API
      - name: Checkout for release notes
        if: steps.release.outputs.releases_created == 'true'
        uses: actions/checkout@v6

      - name: Create GitHub Releases
        if: steps.release.outputs.releases_created == 'true'
        run: |
          echo "Creating GitHub releases for merged release PR..."

          # Process each chart that has a release
          for chart_path in charts/*/; do
            chart_name=$(basename "$chart_path")

            # Map chart names to output format (replace / with --)
            output_key="charts/${chart_name}"

            # Check if this chart has a release (access outputs via env vars)
            case "$chart_name" in
              cloudflared)
                release_created="${CLOUDFLARED_RELEASE_CREATED}"
                tag_name="${CLOUDFLARED_TAG_NAME}"
                version="${CLOUDFLARED_VERSION}"
                sha="${CLOUDFLARED_SHA}"
                ;;
              mdbook-htmx)
                release_created="${MDBOOK_HTMX_RELEASE_CREATED}"
                tag_name="${MDBOOK_HTMX_TAG_NAME}"
                version="${MDBOOK_HTMX_VERSION}"
                sha="${MDBOOK_HTMX_SHA}"
                ;;
              olm)
                release_created="${OLM_RELEASE_CREATED}"
                tag_name="${OLM_TAG_NAME}"
                version="${OLM_VERSION}"
                sha="${OLM_SHA}"
                ;;
              *)
                continue
                ;;
            esac

            if [ "$release_created" = "true" ]; then
              echo "ðŸ“¦ Creating release for $chart_name v$version (tag: $tag_name)"

              # Get changelog content for this version
              changelog_file="$chart_path/CHANGELOG.md"
              if [ -f "$changelog_file" ]; then
                # Extract changelog section for this version
                release_notes=$(awk "/^## \[$version\]/{flag=1; next} /^## \[/{flag=0} flag" "$changelog_file")
              else
                release_notes="Release $chart_name v$version"
              fi

              # Create the release
              gh release create "$tag_name" \
                --target "$sha" \
                --title "$chart_name: v$version" \
                --notes "$release_notes" \
                || echo "âš ï¸ Release $tag_name may already exist"

              # Update PR label from 'autorelease: pending' to 'autorelease: tagged'
              pr_number=$(gh pr list --state merged --search "release $chart_name $version" --json number --jq '.[0].number' 2>/dev/null || true)
              if [ -n "$pr_number" ]; then
                gh pr edit "$pr_number" --remove-label "autorelease: pending" --add-label "autorelease: tagged" 2>/dev/null || true
              fi

              echo "âœ… Created release $tag_name"
            fi
          done
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          CLOUDFLARED_RELEASE_CREATED: ${{ steps.release.outputs['charts/cloudflared--release_created'] }}
          CLOUDFLARED_TAG_NAME: ${{ steps.release.outputs['charts/cloudflared--tag_name'] }}
          CLOUDFLARED_VERSION: ${{ steps.release.outputs['charts/cloudflared--version'] }}
          CLOUDFLARED_SHA: ${{ steps.release.outputs['charts/cloudflared--sha'] }}
          MDBOOK_HTMX_RELEASE_CREATED: ${{ steps.release.outputs['charts/mdbook-htmx--release_created'] }}
          MDBOOK_HTMX_TAG_NAME: ${{ steps.release.outputs['charts/mdbook-htmx--tag_name'] }}
          MDBOOK_HTMX_VERSION: ${{ steps.release.outputs['charts/mdbook-htmx--version'] }}
          MDBOOK_HTMX_SHA: ${{ steps.release.outputs['charts/mdbook-htmx--sha'] }}
          OLM_RELEASE_CREATED: ${{ steps.release.outputs['charts/olm--release_created'] }}
          OLM_TAG_NAME: ${{ steps.release.outputs['charts/olm--tag_name'] }}
          OLM_VERSION: ${{ steps.release.outputs['charts/olm--version'] }}
          OLM_SHA: ${{ steps.release.outputs['charts/olm--sha'] }}

  release-charts:
    needs: release-please
    # Run if release-please created releases OR if manually triggered with force_release
    # Use always() to run even if release-please job fails (e.g., when manually forcing)
    if: always() && (needs.release-please.outputs.releases_created == 'true' || inputs.force_release == true)
    runs-on: ubuntu-latest
    permissions:
      contents: write
      packages: write
      id-token: write
      attestations: write
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Configure Git
        run: |
          git config user.name "$GITHUB_ACTOR"
          git config user.email "$GITHUB_ACTOR@users.noreply.github.com"

      - name: Set up Helm
        uses: azure/setup-helm@v4
        with:
          version: v3.14.0

      - name: Install Cosign
        uses: sigstore/cosign-installer@v3

      - name: Set registry (lowercase for OCI)
        run: |
          echo "REGISTRY=ghcr.io/${GITHUB_REPOSITORY_OWNER,,}/charts" >> $GITHUB_ENV

      - name: Login to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # ============================================================
      # 1. GitHub Releases + Charts Branch (via chart-releaser)
      # ============================================================
      - name: Run chart-releaser
        uses: helm/chart-releaser-action@v1.7.0
        with:
          charts_dir: charts
          pages_branch: charts
          skip_existing: true
        env:
          CR_TOKEN: "${{ secrets.GITHUB_TOKEN }}"

      # ============================================================
      # 2. Sign GitHub Release assets (.tgz files)
      # ============================================================
      - name: Sign GitHub Release assets
        run: |
          for chart in charts/*/; do
            if [ -f "$chart/Chart.yaml" ]; then
              chart_name=$(grep '^name:' "$chart/Chart.yaml" | awk '{print $2}')
              version=$(grep '^version:' "$chart/Chart.yaml" | awk '{print $2}')
              tgz_file=".cr-release-packages/${chart_name}-${version}.tgz"

              if [ -f "$tgz_file" ]; then
                echo "ðŸ” Signing GitHub Release asset: $tgz_file"
                cosign sign-blob --yes --output-signature "${tgz_file}.sig" "$tgz_file"

                # Upload signature to GitHub Release
                gh release upload "${chart_name}-${version}" "${tgz_file}.sig" --clobber || true
                echo "âœ… Uploaded signature to release ${chart_name}-${version}"
              fi
            fi
          done
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # ============================================================
      # 3. GHCR / GitHub Packages (OCI Registry) + Sign by Digest
      # ============================================================
      - name: Push and sign charts to GHCR
        run: |
          for chart in charts/*/; do
            if [ -f "$chart/Chart.yaml" ]; then
              chart_name=$(grep '^name:' "$chart/Chart.yaml" | awk '{print $2}')
              version=$(grep '^version:' "$chart/Chart.yaml" | awk '{print $2}')
              tgz_file=".cr-release-packages/${chart_name}-${version}.tgz"

              # Package if needed
              if [ ! -f "$tgz_file" ]; then
                echo "ðŸ“¦ Packaging $chart_name:$version..."
                helm package "$chart" -d .cr-release-packages/
              fi

              # Push and capture digest
              echo "ðŸš€ Pushing $chart_name:$version to GHCR..."
              push_output=$(helm push "$tgz_file" oci://$REGISTRY 2>&1)
              echo "$push_output"

              # Extract digest from helm push output (format: "Digest: sha256:...")
              digest=$(echo "$push_output" | grep -oP 'Digest: \Ksha256:[a-f0-9]+')
              echo "âœ… Published $chart_name:$version (digest: $digest)"

              # Sign by digest (not tag) for security
              if [ -n "$digest" ]; then
                echo "ðŸ” Signing $REGISTRY/${chart_name}@${digest}..."
                cosign sign --yes "$REGISTRY/${chart_name}@${digest}"
                echo "âœ… Signed $chart_name:$version on GHCR"
              else
                echo "âš ï¸ Could not extract digest, skipping signing for $chart_name:$version"
              fi
            fi
          done

      # ============================================================
      # 4. Generate build attestations
      # ============================================================
      - name: Generate attestations for chart packages
        uses: actions/attest-build-provenance@v3
        with:
          subject-path: '.cr-release-packages/*.tgz'

      # ============================================================
      # Summary
      # ============================================================
      - name: Generate release summary
        run: |
          echo "## ðŸš€ Charts Released" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Chart | Version | GitHub Release | GHCR | Signed |" >> $GITHUB_STEP_SUMMARY
          echo "|-------|---------|----------------|------|--------|" >> $GITHUB_STEP_SUMMARY

          for chart in charts/*/; do
            if [ -f "$chart/Chart.yaml" ]; then
              chart_name=$(grep '^name:' "$chart/Chart.yaml" | awk '{print $2}')
              version=$(grep '^version:' "$chart/Chart.yaml" | awk '{print $2}')
              gh_release="[${chart_name}-${version}](https://github.com/${{ github.repository }}/releases/tag/${chart_name}-${version})"
              ghcr_link="[\`$REGISTRY/${chart_name}:${version}\`](https://github.com/${{ github.repository_owner }}/packages/container/charts%2F${chart_name})"
              echo "| $chart_name | $version | $gh_release | $ghcr_link | âœ… |" >> $GITHUB_STEP_SUMMARY
            fi
          done

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Verification" >> $GITHUB_STEP_SUMMARY
          echo '```bash' >> $GITHUB_STEP_SUMMARY
          echo "# Verify GHCR signature" >> $GITHUB_STEP_SUMMARY
          echo "cosign verify $REGISTRY/<chart>:<version>" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "# Verify GitHub Release signature" >> $GITHUB_STEP_SUMMARY
          echo "cosign verify-blob --signature <chart>-<version>.tgz.sig <chart>-<version>.tgz" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
